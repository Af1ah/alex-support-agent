import { type NextRequest, NextResponse } from "next/server"
import { GoogleGenerativeAI } from "@google/generative-ai"
import { sendEmail } from "@/lib/email-service"
import { DatabaseService } from "@/lib/database-service"
import { CacheService } from "@/lib/cache-service"
import { StatusService } from "@/lib/status-service"
import { aiInstructions } from '@/lib/ai-service/instructions'

// Initialize services
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || "")
const dbService = new DatabaseService()
const cacheService = new CacheService()
const statusService = new StatusService()

export const maxDuration = 30

export async function POST(req: NextRequest) {
  try {
    const { message, history } = await req.json()

    if (!process.env.GEMINI_API_KEY) {
      return NextResponse.json({
        response: "I'm sorry, but I'm not properly configured. Please check the API key configuration.",
      })
    }

    // Check cache first for optimization
    const cacheKey = `chat:${message.toLowerCase().trim()}`
    const cachedResponse = await cacheService.get(cacheKey)

    if (cachedResponse) {
      return NextResponse.json({
        response: cachedResponse,
        cached: true,
      })
    }

    // Analyze message for function triggers
    const functionTriggers = await analyzeMessageForFunctions(message)

    // Execute triggered functions
    const functionResults = await executeFunctions(functionTriggers, message)

    // Prepare context with function results
    const contextualMessage = await prepareContextualMessage(message, functionResults, history)

    // Generate AI response with Gemini
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      systemInstruction: aiInstructions.instructions,
    })

    const result = await model.generateContent(contextualMessage)
    const response = result.response
    const aiResponse = response.text() || "I apologize, but I encountered an issue processing your request."

    // Cache the response for future optimization
    await cacheService.set(cacheKey, aiResponse, 300) // 5 minutes cache

    return NextResponse.json({
      response: aiResponse,
      functionResults,
      cached: false,
    })
  } catch (error) {
    console.error("Chat API error:", error)

    // Return a user-friendly error message
    return NextResponse.json({
      response: "I apologize, but I'm experiencing technical difficulties. Please try again in a moment.",
      error: true,
    })
  }
}

async function analyzeMessageForFunctions(message: string): Promise<string[]> {
  const triggers = []
  const lowerMessage = message.toLowerCase()

  // Email triggers
  if (lowerMessage.includes("send email") || lowerMessage.includes("email")) {
    triggers.push("email")
  }

  // Database lookup triggers
  if (lowerMessage.includes("find") || lowerMessage.includes("search") || lowerMessage.includes("lookup")) {
    triggers.push("database")
  }

  // Status check triggers
  if (lowerMessage.includes("status") || lowerMessage.includes("health") || lowerMessage.includes("check")) {
    triggers.push("status")
  }

  return triggers
}

async function executeFunctions(triggers: string[], message: string): Promise<any> {
  const results: any = {}

  for (const trigger of triggers) {
    try {
      switch (trigger) {
        case "email":
          results.email = await handleEmailFunction(message)
          break
        case "database":
          results.database = await handleDatabaseFunction(message)
          break
        case "status":
          results.status = await handleStatusFunction()
          break
      }
    } catch (error) {
      console.error(`Function ${trigger} error:`, error)
      results[trigger] = { error: `Failed to execute ${trigger} function` }
    }
  }

  return results
}

async function handleEmailFunction(message: string) {
  try {
    const emailData = {
      to: "support@example.com",
      subject: "Support Request from Alex AI",
      body: `User message: ${message}\n\nGenerated by Alex AI Support Agent`,
    }

    const result = await sendEmail(emailData)
    return { sent: result.success, messageId: result.messageId }
  } catch (error) {
    return { error: "Email function temporarily unavailable" }
  }
}

async function handleDatabaseFunction(message: string) {
  try {
    const searchTerm = extractSearchTerm(message)
    const results = await dbService.search(searchTerm)
    return { results: results.slice(0, 5) }
  } catch (error) {
    return { error: "Database search temporarily unavailable" }
  }
}

async function handleStatusFunction() {
  try {
    const status = await statusService.getSystemStatus()
    return status
  } catch (error) {
    return { error: "Status check temporarily unavailable" }
  }
}

function extractSearchTerm(message: string): string {
  const words = message.toLowerCase().split(" ")
  const stopWords = ["find", "search", "lookup", "for", "the", "a", "an"]
  return words.filter((word) => !stopWords.includes(word)).join(" ")
}

async function prepareContextualMessage(message: string, functionResults: any, history: any[]): Promise<string> {
  let contextualMessage = message

  if (Object.keys(functionResults).length > 0) {
    contextualMessage += "\n\nFunction Results:\n"
    contextualMessage += JSON.stringify(functionResults, null, 2)
  }

  if (history && history.length > 0) {
    const recentHistory = history.slice(-3)
    contextualMessage += "\n\nRecent Conversation:\n"
    recentHistory.forEach((msg: any) => {
      contextualMessage += `${msg.role}: ${msg.content}\n`
    })
  }

  return contextualMessage
}
